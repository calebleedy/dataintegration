---
title: "Non-Nested Two Phase Debiased Calibration Simulation"
author: "Caleb Leedy"
from: markdown+emoji
format: 
  html:
    embed-resources: true
    code-fold: true
    grid:
      margin-width: 450px
bibliography: references.bib
reference-location: margin
comments:
  hypothesis: true
---

# Summary

This report simulates non-nested two-phase sampling with the debiased
calibration of @kwon2024debiased. We check for the following:

1. Bias of $\hat Y$ and,
2. Bias of $\hat V(\hat Y)$.

For the estimator $\hat Y$ we construct 

1. The $\pi^*$-estimator,
2. The two-phase regression estimator,
3. The debiased calibration estimator (with known finite population total), and
4. The debiased calibration estimator with estimated population totals from the
   Phase 1 sample.

# Simulation Setup

```{r}
#| label: setup

B_sims <- 1000

N_obs <- 10000
n1_obs <- 1000
n2_obs <- 500

library(dplyr)
library(GECal)
library(nleqslv)
library(doParallel)
library(doRNG)
library(CVXR)
library(rlang)

# source("GEcalib_code.R")

```

We have the following superpopulation model:

$$
\begin{aligned}
X_{1i} &\stackrel{ind}{\sim} N(2, 1) \\
X_{2i} &\stackrel{ind}{\sim} Unif(0, 4) \\
X_{3i} &\stackrel{ind}{\sim} N(0, 1) \\
X_{4i} &\stackrel{ind}{\sim} Unif(0.1, 0.9) \\
\varepsilon_i &\stackrel{ind}{\sim} N(0, 1) \\
Y_{i} &= 3 X_{1i} + 2 X_{2i} + \varepsilon_i \\
\pi_{1i} &= \Phi(-x_{3i} - 2)\\
\pi_{2i|1} &= x_{4i}.
\end{aligned}
$$

and the non-nested two-phase sampling scheme is to select a SRS of 
size $n = $`{r} n1_obs`
from a finite population of size $N = $`{r} N_obs` for the Phase 1 sample,
$A_1$, and a Poisson sample with expected size $r =$`{r} n2_obs` for the Phase 2
sample, $A_2$. We only observe $Y$ in the Phase 2 sample, but we observe 
$(X_1, X_2)$ in both $A_1$ and $A_2$.

```{r}
#| label: generate population and samples

gen_pop <- function(obs) {

  x1 <- rnorm(obs, 2, 1)
  x2 <- runif(obs, 0, 4)
  x3 <- rnorm(obs, 0, 1)
  x4 <- runif(obs, 0.1, 0.9)
  eps <- rnorm(obs)

  y <- 3 * x1 + 2 * x2 + eps

  return(tibble(X1 = x1, X2 = x2, X3 = x3, X4 = x4, Y = y))
}

#' This function adds sampling probabilites to a population data frame.
#'
#' @details The phase 2 formula will be included for every element. There is no
#' information about if an element is part of the Phase 1 or Phase 2 sample.
update_pop <- function(pop_df, p1_formula, p2_formula) {

  pi1 <- eval(parse_expr(p1_formula))
  pi2 <- eval(parse_expr(p2_formula))

  pop_df %>%
    mutate(pi1 = pi1, pi2 = pi2)
}

#' This function generates Phase 1 and Phase 2 samples from an updated
#' population with selection probabilites.
gen_samps <- function(upop_df, p1_type, p2_type) {

  if (p1_type == "poisson") {
    del1 <- rbinom(nrow(upop_df), 1, upop_df$pi1)
  } else if (p1_type == "srs") {
    ind <- sample(1:nrow(upop_df), size = upop_df$pi1[1] * nrow(upop_df))
    del1 <- as.numeric(1:nrow(upop_df) %in% ind)
  } else {
    stop("We have only implemented poisson and srs for Phase 1.")
  }

  p1_df <- mutate(upop_df, del1 = del1) %>% filter(del1 == 1)

  if (p2_type == "poisson") {
    del2 <- rbinom(nrow(upop_df), 1, upop_df$pi2)
  } else if (p2_type == "srs") {
    ind <- sample(1:nrow(upop_df), size = round(upop_df$pi2[1] * nrow(upop_df)))
    del2 <- as.numeric(1:nrow(upop_df) %in% ind)
  } else {
    stop("We have only implemented poisson and srs for Phase 2.")
  }

  p2_df <- mutate(upop_df, del2 = del2) %>% filter(del2 == 1)

  return(list(p1_df, p2_df))
}

```

```{r}
#| label: estimators


```





```{r}
#| label: run MCMC

set.seed(1)
pop_df <- gen_pop(N_obs)
true_theta <- mean(pop_df$Y)

upop_df <-
  update_pop(
    pop_df,
    "n1_obs / N_obs",
    "ifelse(pt(-pop_df$X1 + 1, 3) > 0.9, 0.9, pt(-pop_df$X1 + 1, 3))"
  )

gen_samps(upop_df, "srs", "poisson")

```


